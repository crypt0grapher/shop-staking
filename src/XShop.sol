// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

//import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
import "lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";
import "lib/openzeppelin-contracts/contracts/access/Ownable.sol";
import "lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol";
import "lib/v2-core/contracts/interfaces/IERC20.sol";
/// @title A shop staking contract
/// @author crypt0grapher
/// @notice this contract stakes SHOP tokens and allows users to earn rewards from the fees generated by the platform

contract XSHOP is ERC20, Ownable, ReentrancyGuard {
    event Snapshot(uint256 rewards, address indexed from, uint256 shopMinted);
    event Deposited(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    event Claimed(address indexed user, uint256 reward);
    event ReinvestingToggled(address indexed user, bool status);

    IERC20 public constant shopToken = IERC20(0x99e186E8671DB8B10d45B7A1C430952a9FBE0D40);

    uint256 public minimumStake = 20000 * 10e18;
    uint256 public timeLock = 5 days;

    uint256 public epochDuration = 1 days;
    uint256 public rewardPool;

    struct EpochInfo {
        uint256 timestamp;
        uint256 rewards;
        uint256 totalStaked;
        uint256 shopSwapped;
        uint256 shopPrice;
    }

    uint256 public currentEpoch;
    mapping(uint256 => EpochInfo) public epochInfo;

    struct UserInfo {
        //epoch => total amount deposited during the epoch
        mapping(uint256 => uint256) depositedInEpoch;
        mapping(uint256 => bool) isAutoCompoundingOn;
        // a starting epoch for reward calculation for user - either last claimed or first deposit
        uint256 lastClaimedEpoch;
        uint256 lastClaimedInEpoch;
        uint256 lastEpochReinvested;
    }

    mapping(address => UserInfo) public userInfo;

    uint256 public reinvestorsCount;
    mapping(address => uint256) public reinvestorsIndex;
    mapping(uint256 => address) public reinvestors;


    constructor() ReentrancyGuard() Ownable() ERC20("Staked SHOP", "xSHOP") {
    }

    function setMinimumStake(uint256 _minimumStake) public onlyOwner {
        minimumStake = _minimumStake;
    }

    function setTimeLock(uint256 _timeLock) public onlyOwner {
        timeLock = _timeLock;
    }

    function setAutoCompounding(bool _status) public {
        isAutoCompounding[msg.sender] = _status;
    }

    function deposit(uint256 amount) public {
        require(amount + balanceOf(msg.sender) > minimumStake, "Amount must be greater than 20K $SHOP");
        require(shopToken.transferFrom(msg.sender, address(this), amount), "Transfer failed");

        _updateStake(msg.sender, amount, true);

        emit Deposited(msg.sender, amount);
    }

    function withdraw(uint256 amount) public {
        require(balanceOf(msg.sender) >= amount, "Insufficient balance");

        _updateStake(msg.sender, amount, false);

        require(shopToken.transfer(msg.sender, amount), "Transfer failed");

        emit Withdrawn(msg.sender, amount);
    }

    function claimReward() public {
        require(currentEpoch > 0, "No rewards have been distributed yet");
        uint256 lastSnapshotTime = epochInfo[currentEpoch - 1].timestamp;
        require(lastSnapshotTime + epochDuration < block.timestamp, "Too early to calculate rewards");
        require(!isAutoCompounding[msg.sender], "Auto-compounding is enabled");
        uint256 reward = calculateReward(msg.sender);
        require(reward > 0, "No reward available");
        lastClaimedInEpoch[msg.sender] = currentEpoch;
        payable(msg.sender).transfer(reward);

        emit Claimed(msg.sender, reward);
    }

    function snapshot() public payable nonReentrant {
        uint256 lastSnapshotTime = epochInfo[currentEpoch - 1].timestamp;
        require(block.timestamp >= lastSnapshotTime + epochDuration - 5 minutes, "Too early for a new snapshot");
        require(msg.value > 0, "ETH amount must be greater than 0");
        epochInfo[currentEpoch].rewards = msg.value;
        epochInfo[currentEpoch].timestamp = block.timestamp;
        epochInfo[currentEpoch].totalStaked = totalSupply();
        epochInfo[currentEpoch].shopPrice = _shopPrice;
        currentEpoch++;
        // swap ETH for autocompounding

        uint256 ethToSell = 0;
        for (uint256 i = 1; i <= reinvestorsCount; i++) {
            ethToSell += _calculateRewardToReinvest(reinvestors[i]);
            if (ethToReinvest > 0) {
                userInfo[reinvestors[i]].lastEpochReinvested = currentEpoch;
            }
        }
        uint256 xShopToMintTotal = swapEthForShop(ethToSell);
        epochInfo[currentEpoch].shopSwapped = xShopToMintTotal;
        emit Snapshot(msg.value, msg.sender, xShopToMintTotal);
    }

    function _updateStake(address user, uint256 amount, bool isDeposit) internal {
        if (isDeposit) {
            deposits[user][currentEpoch] += amount;
            _mint(user, amount);
        } else {
            uint256 remainingAmountToWithdraw = amount;
            for (uint256 i = 0; i <= currentEpoch; i++) {
                if (remainingAmountToWithdraw == 0) {
                    break;
                }
                uint256 amountToWithdraw = deposits[user][i];
                if (amountToWithdraw > remainingAmountToWithdraw) {
                    amountToWithdraw = remainingAmountToWithdraw;
                }
                deposits[user][i] -= amountToWithdraw;
                remainingAmountToWithdraw -= amountToWithdraw;
            }
            _burn(user, amount);
        }
    }


    function calculateReward(address user) public view returns (uint256) {
        uint256 reward = 0;
        uint256 userBalanceInEpoch = 0;
        UserInfo userInfo = userInfo[user];
        for (uint256 i = userInfo.lastClaimedEpoch; i < currentEpoch; i++) {
            userBalanceInEpoch +=  userInfo[user].depositedInEpoch[i];
            if (!userInfo.isAutoCompoundingOn) {
                uint256 epochReward = userBalanceInEpoch * epochInfo[i].rewards / epochInfo[i].totalStaked;
                reward += epochReward;
            }
        }
        return reward;
    }

    function toggleAutoCompounding() public {
        bool currentStatus = getReinvestingStatus(msg.sender);
        userInfo[msg.sender].isAutoCompoundingOn[currentEpoch] = !currentStatus;
        if (currentStatus) {
            if (reinvestorsIndex[msg.sender] == 0) {
                reinvestorsCount++;
                reinvestorsIndex[msg.sender] = compoundersCount;
                reinvestors[compoundersCount] = msg.sender;
            }
        }
        else {
            if (reinvestorsIndex[msg.sender] != 0) {
                uint256 index = reinvestorsIndex[msg.sender];
                address lastReinvestor = reinvestors[msg.sendersCount];

                // Swap the msg.sender to remove with the last msg.sender
                reinvestors[index] = lastReinvestor;
                reinvestorsIndex[lastReinvestor] = index;

                // Remove the last msg.sender and update count
                delete reinvestors[msg.sendersCount];
                delete reinvestorsIndex[msg.sender];
                reinvestorsCount--;
            }
        }
        emit ReinvestingToggled(msg.sender, !currentStatus);
    }


    function swapEthForShop(uint256 ethAmount) public returns (uint256) {
        require(msg.sender == owner, "Only the owner can execute this function");

        // Generate the Uniswap pair path of WETH -> SHOP
        address[] memory path = new address[](2);
        path[0] = uniswapRouter.WETH();
        path[1] = shopToken;

        uint256 deadline = block.timestamp + 15; // 15 seconds from the current block time

        // Swap and return the amount of SHOP tokens received
        uint[] memory amounts = uniswapRouter.swapExactETHForTokens{ value: ethAmount }(
            0, // Accept any amount of SHOP
            path,
            address(this),
            deadline
        );

        // Return the amount of SHOP tokens received
        return amounts[1];
    }

    function rescueETH(uint256 weiAmount) external {
        payable(owner()).transfer(weiAmount);
    }

    function rescueERC20(address tokenAdd, uint256 amount) external {
        IERC20(tokenAdd).transfer(owner(), amount);
    }

    function getReinvestingStatus(address _user) public view returns (bool) {
        for (uint256 i = currentEpoch; i > 0; i--) {
            if (userInfo[_user].isAutoCompoundingOn[i]) {
                return true;
            }
        }
        return false;
    }

// Mock function for demonstration purposes. In reality, you'd interact with a decentralized exchange contract here.
    function _calculateRewardToReinvest(address user) private view returns (uint256) {
        uint256 rewardsToReinvest = 0;
        uint256 userBalanceInEpoch = 0;
        UserInfo userInfo = userInfo[user];
        for (uint256 i = userInfo.lastEpochReinvested; i < currentEpoch; i++) {
            userBalanceInEpoch += userInfo[user].depositedInEpoch[i];
            if (userInfo.isAutoCompoundingOn) {
                uint256 epochReward = userBalanceInEpoch * epochInfo[i].rewards / epochInfo[i].totalStaked;
                rewardsToReinvest = epochReward;
            }
        }
        return rewardsToReinvest;
    }

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal pure override {
        require(from == address(0) || to == address(0), "Only stake or unstake");
    }

}
